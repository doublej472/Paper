From 6443f54ff92cdbe9e974d7c9c49225cbf4be9e69 Mon Sep 17 00:00:00 2001
From: Kyle Wood <demonwav@gmail.com>
Date: Sun, 16 Jun 2019 21:20:10 -0500
Subject: [PATCH] Implement daemon mode to interop with paperd


diff --git a/pom.xml b/pom.xml
index 1f3571dd0..0e2c13b33 100644
--- a/pom.xml
+++ b/pom.xml
@@ -49,7 +49,6 @@
             <groupId>net.java.dev.jna</groupId>
             <artifactId>jna</artifactId>
             <version>4.5.2</version>
-            <scope>runtime</scope>
         </dependency>
         <!--
           Required to add the missing Log4j2Plugins.dat file from log4j-core
diff --git a/src/main/java/com/destroystokyo/paper/PaperDaemon.java b/src/main/java/com/destroystokyo/paper/PaperDaemon.java
new file mode 100644
index 000000000..10b9c38c5
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/PaperDaemon.java
@@ -0,0 +1,789 @@
+package com.destroystokyo.paper;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.io.ByteArrayDataOutput;
+import com.google.common.io.ByteStreams;
+import com.google.gson.Gson;
+import com.sun.jna.LastErrorException;
+import com.sun.jna.Native;
+import com.sun.jna.NativeLong;
+import com.sun.jna.Pointer;
+import com.sun.jna.Structure;
+import it.unimi.dsi.fastutil.ints.Int2IntArrayMap;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectArrayMap;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.stream.Collectors;
+import net.minecraft.server.DedicatedServer;
+import org.apache.commons.lang3.text.WordUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.Player;
+
+public final class PaperDaemon {
+
+    private static final String PID_FILE = "paper.pid";
+    private static final long MESSAGE_TYPE = 0x7654;
+
+    private static final Gson gson = new Gson();
+
+    /**
+     * Used to synchronize {@link #messageMap}.
+     */
+    private static final Object messageLock = new Object();
+    /**
+     * Used to synchronize {@link #channelMap}.
+     */
+    private static final Object channelLock = new Object();
+
+    /**
+     * Stores data from message queue messages to build a full string through multiple messages. Kept as {@code null}
+     * while not in use, and all accesses must be synchronized through {@link #messageLock}.
+     */
+    private static Int2ObjectArrayMap<ByteArrayDataOutput> messageMap = null;
+    /**
+     * Stores client channels associated with their PID. Will be checked periodically to make sure there aren't open
+     * channels after their owning PID is gone, i.e. the {@code paperd} process crashed. Kept as {@code null} while
+     * not in use, and all accesses must be synchronized through {@link #channelLock}.
+     */
+    private static Int2IntArrayMap channelMap = null;
+
+    private static boolean loop = true;
+
+    /**
+     * Setups up the necessary infrastructure for running the server in daemon mode if <b>both</b> of the following
+     * are true::
+     * <ul>
+     *   <li>The {@code io.papermc.daemon.enabled property} is set to {@code true}</li>
+     *   <li>The OS is Unix, namely Linux and macOS are checked</li>
+     * </ul>
+     * In the instance that the above checks are satisfied, the following things will happen:
+     * <ul>
+     *   <li>{@code stdout} ({@link System#out}) will be closed</li>
+     *   <li>{@code stderr} ({@link System#err}) will be closed</li>
+     *   <li>{@code stdin} ({@link System#in}) will be closed</li>
+     *   <li>A XSI Message Queue will be opened using the PID file {@code paper.pid} (this will allow
+     *   {@code paperd} to communicate with the running server)</li>
+     *   <li>This method will return {@code true}</li>
+     * </ul>
+     * <p>
+     * If the above checks are not satisfied, this method does nothing and will return {@code false}.
+     *
+     * @return {@code true} if the server is running in daemon mode.
+     */
+    public static boolean init() {
+        if (!"true".equals(System.getProperty("io.papermc.daemon.enabled"))) {
+            return false;
+        }
+
+        final String osName = System.getProperty("os.name").toLowerCase();
+        if (!osName.contains("nux") && !osName.contains("nix") &&
+            !osName.contains("mac os") && !osName.contains("macos")
+        ) {
+            System.out.println("ERROR: Property io.papermc.daemon.enabled was true, but this is not running on a " +
+                "Unix system, so the option will be ignored.");
+            System.out.println("    System type: " + osName);
+            return false;
+        }
+
+        final Path pidFile = Paths.get(PID_FILE);
+        if (!Files.exists(pidFile)) {
+            System.out.println("ERROR: PID file not found: " + pidFile.toAbsolutePath());
+            System.out.println("    Did you start this from paperd?");
+            System.out.println("    Stopping the server due to previous error.");
+            System.exit(1);
+            throw new InternalError();
+        }
+
+        // Create message queue
+        final int msqid = beginMessageLoop(pidFile);
+        registerShutdownHook(msqid);
+
+        // When running as a daemon, we won't have stdout, stderr, and stdin
+        // If we leave this around as normal then that will cause crashes elsewhere,
+        // since paperd has already closed them
+        // Set them to a PrintStream which does nothing, rather than null, to prevent NPE errors
+        final PrintStream stream = new PrintStream(new OutputStream() {
+            @Override
+            public void write(int b) {
+            }
+        });
+        System.setOut(stream);
+        System.setErr(stream);
+
+        System.setIn(new InputStream() {
+            @Override
+            public int read() {
+                // block forever
+                // noinspection InfiniteLoopStatement
+                while (true) {
+                    try {
+                        this.wait();
+                    } catch (final InterruptedException ignored) {
+                    }
+                }
+            }
+        });
+
+        return true;
+    }
+
+    /**
+     * Registers a {@link Runtime#addShutdownHook(Thread) shutdown hook} to remove the XSI Message Queue at
+     * shutdown. Message queues are not cleaned up when all processes using it finish, they will hang around until
+     * reboot if not cleaned up. We can't handle cases where the JVM is killed unexpectedly with {@code SIGKILL}, but
+     * this will allow us to handle most other cases.
+     * <p>
+     * As an extra precaution against rogue message queues hanging around, {@code paperd} will also remove queues
+     * related to PID files of already stopped servers.
+     *
+     * @param msqid The queue id to remove.
+     */
+    private static void registerShutdownHook(final int msqid) {
+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
+            // Tell the message queue loop it should quit
+            loop = false;
+
+            try {
+                IPCLibrary.msgctl(msqid, IPCLibrary.IPC_RMID, Pointer.NULL);
+            } catch (final LastErrorException e) {
+                final String msg = IPCLibrary.strerror(e.getErrorCode());
+                throw new PaperDaemonException("Failed to delete IPC message queue: " + msg);
+            }
+        }));
+    }
+
+    /**
+     * Begins listening and responding to XSI Message Queue messages. This method will loop forever in a
+     * separate {@link Thread#setDaemon(boolean) daemon} thread.
+     * <p>
+     * The message queue will be attempted to be closed in the {@link Runtime#addShutdownHook(Thread) shutdown hook}
+     * added by the {@link #registerShutdownHook(int) registerShutdownHook}, this method cannot cleanup after itself.
+     * Because of this, {@link #registerShutdownHook(int) registerShutdownHook} must be called after this method with
+     * the return value of this method as input.
+     *
+     * @return The msqid of the created queue.
+     */
+    private static int beginMessageLoop(final Path pidFile) {
+        final String pidPath = pidFile.toAbsolutePath().toString();
+        final int key;
+        try {
+            key = IPCLibrary.ftok(pidPath, 'P');
+        } catch (final LastErrorException e) {
+            final String msg = IPCLibrary.strerror(e.getErrorCode());
+            throw new PaperDaemonException("Failed to retrieve IPC message queue key: " + msg);
+        }
+
+        final int msqid;
+        try {
+            //noinspection OctalInteger
+            msqid = IPCLibrary.msgget(new NativeLong(key), 0666 | IPCLibrary.IPC_CREAT);
+        } catch (final LastErrorException e) {
+            final String msg = IPCLibrary.strerror(e.getErrorCode());
+            throw new PaperDaemonException("Failed to get or create IPC message queue: " + msg);
+        }
+
+        {
+            final Thread t = new Thread(() -> {
+                while (loop) {
+                    doMessageLoop(msqid);
+                }
+            });
+            t.setDaemon(true);
+            t.setName("IPC Message Queue Thread");
+            t.start();
+        }
+
+        {
+            final Thread t = new Thread(() -> {
+                while (loop) {
+                    cleanupBuffers();
+                    try {
+                        Thread.sleep(TimeUnit.SECONDS.toMillis(10));
+                    } catch (final InterruptedException e) {
+                        break;
+                    }
+                }
+            });
+            t.setDaemon(true);
+            t.setName("IPC Message Queue Buffer Cleanup Thread");
+            t.start();
+        }
+
+        return msqid;
+    }
+
+    /**
+     * Executes a single iteration of the message loop handler thread. This should be called in an infinite loop inside
+     * a {@link Thread#setDaemon(boolean) daemon thread}.
+     *
+     * @param msqid The message queue id to use to listen for messages.
+     */
+    private static void doMessageLoop(final int msqid) {
+        final IPCLibrary.MsgBuf buf = new IPCLibrary.MsgBuf();
+
+        try {
+            IPCLibrary.msgrcv(msqid, buf, buf.data.size(), MESSAGE_TYPE, 0);
+        } catch (final LastErrorException e) {
+            final String msg = IPCLibrary.strerror(e.getErrorCode());
+            log(logger -> logger.warning("Failed to read from message queue: " + msg));
+            return;
+        }
+
+        final byte mask = (byte) 0x80;
+        final boolean isFin = (buf.data.messageLength & mask) == mask;
+
+        final byte clear = isFin ? (byte) 0x7F /* clear 1st bit */ : (byte) 0xFF /* do nothing */;
+        final int length = buf.data.messageLength & clear;
+
+        final ByteArrayDataOutput buffer;
+        synchronized (messageLock) {
+            if (messageMap == null) {
+                messageMap = new Int2ObjectArrayMap<>();
+            }
+            //noinspection UnstableApiUsage
+            buffer = messageMap.computeIfAbsent(buf.data.responsePid, i -> ByteStreams.newDataOutput());
+        }
+        buffer.write(buf.data.message, 0, length);
+
+        if (isFin) {
+            if (buf.data.responseChan != -1) {
+                synchronized (channelLock) {
+                    if (channelMap == null) {
+                        channelMap = new Int2IntArrayMap();
+                    }
+                    channelMap.put(buf.data.responsePid, buf.data.responseChan);
+                }
+            }
+
+            final String message = new String(buffer.toByteArray(), StandardCharsets.UTF_8);
+            handleMessage(buf.data.messageType, message, buf.data.responseChan);
+
+            synchronized (messageLock) {
+                if (messageMap != null) {
+                    messageMap.remove(buf.data.responsePid);
+                    if (messageMap.isEmpty()) {
+                        messageMap = null;
+                    }
+                }
+            }
+        }
+    }
+
+    private static void handleMessage(final short messageType, final String message, final int responseChan) {
+        final Class<? extends Message> clazz = Message.messageTypeMap.get(messageType);
+        final Message handler = gson.fromJson(message, clazz);
+        try {
+            handler.execute(responseChan);
+        } catch (final Throwable t) {
+            log(logger -> logger.log(Level.SEVERE, "Exception thrown in IPC Message Handler: " + clazz.getName(), t));
+        }
+    }
+
+    /**
+     * Check each {@code PID} in {@link #messageMap} and {@link #channelMap} and make sure each process is still alive.
+     * Remove any buffers corresponding with a non-existent PID. This effectively prevents memory leaks from holding
+     * onto buffers for processes which will never complete.
+     */
+    private static void cleanupBuffers() {
+        messages:
+        synchronized (messageLock) {
+            if (messageMap == null) {
+                break messages;
+            }
+
+            final IntIterator iter = messageMap.keySet().iterator();
+            while (iter.hasNext()) {
+                final int pid = iter.nextInt();
+                if (!checkExists(pid)) {
+                    iter.remove();
+                }
+            }
+
+            if (messageMap.isEmpty()) {
+                messageMap = null;
+            }
+        }
+
+        channels:
+        synchronized (channelLock) {
+            if (channelMap == null) {
+                break channels;
+            }
+
+            final ObjectIterator<Int2IntMap.Entry> iter = channelMap.int2IntEntrySet().fastIterator();
+            while (iter.hasNext()) {
+                final Int2IntMap.Entry entry = iter.next();
+
+                final int pid = entry.getIntKey();
+                if (checkExists(pid)) {
+                    continue;
+                }
+                iter.remove();
+
+                try {
+                    IPCLibrary.msgctl(entry.getIntValue(), IPCLibrary.IPC_RMID, Pointer.NULL);
+                } catch (final LastErrorException ignored) {
+                }
+            }
+
+            if (channelMap.isEmpty()) {
+                channelMap = null;
+            }
+        }
+    }
+
+    private static boolean checkExists(final int pid) {
+        try {
+            IPCLibrary.kill(pid, 0);
+        } catch (final LastErrorException e) {
+            final int code = e.getErrorCode();
+            if (code != IPCLibrary.ESRCH) {
+                final String msg = IPCLibrary.strerror(code);
+                log(logger -> logger.warning("Failed to check PID " + pid + ": " + msg));
+            }
+            return false;
+        }
+        return true;
+    }
+
+    private static class IPCLibrary {
+        static final int IPC_RMID = 0;
+        @SuppressWarnings("OctalInteger")
+        static final int IPC_CREAT = 01000;
+        // No such process
+        static final int ESRCH = 3;
+
+        static {
+            Native.register("c");
+        }
+
+        @SuppressWarnings("WeakerAccess")
+        public static class MsgBuf extends Structure {
+            public NativeLong mType;
+            public Data data;
+
+            public MsgBuf() {
+                this.mType = new NativeLong(MESSAGE_TYPE);
+                this.data = new IPCLibrary.Data();
+            }
+
+            @Override
+            protected List<String> getFieldOrder() {
+                return ImmutableList.of("mType", "data");
+            }
+        }
+
+        @SuppressWarnings("WeakerAccess")
+        public static class Data extends Structure {
+            public static final int MESSAGE_LENGTH = 100;
+
+            public int responseChan;
+            public int responsePid;
+            public short messageType;
+            public byte messageLength;
+            public byte[] message = new byte[MESSAGE_LENGTH];
+
+            @Override
+            protected List<String> getFieldOrder() {
+                return ImmutableList.of("responseChan", "responsePid", "messageType", "messageLength", "message");
+            }
+        }
+
+        /**
+         * ftok - convert a pathname and a project identifier to a System V IPC key
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/types.h>
+         * #include <sys/ipc.h>
+         *
+         * key_t ftok(const char *pathname, int proj_id);
+         * }</pre>
+         */
+        public static native int ftok(String pathname, int proj_id) throws LastErrorException;
+
+        /**
+         * msgget — get the XSI message queue identifier
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/msg.h>
+         *
+         * int msgget(key_t key, int msgflg);
+         * }</pre>
+         */
+        public static native int msgget(NativeLong key, int msgflg) throws LastErrorException;
+
+        /**
+         * msgsnd — XSI message send operation
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/msg.h>
+         *
+         * int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
+         * }</pre>
+         */
+        public static native int msgsnd(int msqid, MsgBuf msgp, int msgsz, int msgflg) throws LastErrorException;
+
+        /**
+         * msgrcv — XSI message receive operation
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/msg.h>
+         *
+         * ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
+         *     int msgflg);
+         * }</pre>
+         */
+        public static native int msgrcv(int msqid, MsgBuf msgp, int msgsz, long msgtyp, int msgflg)
+            throws LastErrorException;
+
+        /**
+         * msgctl — XSI message control operations
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/msg.h>
+         *
+         * int msgctl(int msqid, int cmd, struct msqid_ds *buf);
+         * }</pre>
+         */
+        public static native int msgctl(int msqid, int cmd, Pointer buf) throws LastErrorException;
+
+        /**
+         * strerror - return string describing error number
+         * <p/>
+         * <pre>{@literal
+         * #include <string.h>
+         *
+         * char *strerror(int errnum);
+         * }</pre>
+         */
+        public static native String strerror(int errnum);
+
+        /**
+         * kill - send signal to a process
+         * <p/>
+         * <pre>{@literal
+         * #include <sys/types.h>
+         * #include <signal.h>
+         *
+         * int kill(pid_t pid, int sig);
+         * }</pre>
+         */
+        public static native int kill(int pid, int sig) throws LastErrorException;
+    }
+
+    private interface Message {
+        Short2ObjectArrayMap<Class<? extends Message>> messageTypeMap = new Short2ObjectArrayMap<>(ImmutableMap.of(
+            (short) 0, StopMessage.class,
+            (short) 1, SendCommandMessage.class,
+            (short) 2, StatusMessage.class
+        ));
+
+        void execute(final int responseChan);
+
+        /**
+         * Stops the server gracefully.
+         */
+        class StopMessage implements Message {
+            @Override
+            public void execute(final int responseChan) {
+                final DedicatedServer server = getConsole();
+                if (server == null) {
+                    serverNotReadyYet(responseChan);
+                    return;
+                }
+                server.scheduleOnMain(Bukkit::shutdown);
+            }
+        }
+
+        /**
+         * A command to be executed on the server as the console sender.
+         */
+        class SendCommandMessage implements Message {
+            String message;
+
+            @Override
+            public void execute(final int responseChan) {
+                final DedicatedServer server = getConsole();
+                if (server == null) {
+                    serverNotReadyYet(responseChan);
+                    return;
+                }
+                server.scheduleOnMain(() ->
+                    Bukkit.dispatchCommand(Bukkit.getConsoleSender(), message));
+            }
+        }
+
+        /**
+         * Returns various bits of status information about the server:
+         * <ul>
+         *   <li>Server Name</li>
+         *   <li>Server Version</li>
+         *   <li>Server Address</li>
+         *   <li>Server Name</li>
+         *   <li>Number of connected players</li>
+         *   <li>World Info<ul>
+         *       <li>Name</li>
+         *       <li>Dimension</li>
+         *       <li>Seed</li>
+         *       <li>Difficulty</li>
+         *       <li>Players</li>
+         *       <li>Time</li>
+         *   </ul></li>
+         *   <li>TPS</li>
+         *   <li>Memory Usage</li>
+         * </ul>
+         */
+        class StatusMessage implements Message {
+            @Override
+            public void execute(final int responseChan) {
+                final DedicatedServer server = getConsole();
+                if (server == null) {
+                    serverNotReadyYet(responseChan);
+                    return;
+                }
+                server.scheduleOnMain(() -> {
+                    System.out.println("Executing on main");
+                    final String motd = Bukkit.getMotd();
+                    final String serverName = Bukkit.getName();
+                    final String serverVersion = Bukkit.getVersion();
+                    final int numPlayers = Bukkit.getOnlinePlayers().size();
+
+                    final List<WorldStatus> worlds = Bukkit.getWorlds().stream().map(world -> {
+                        final String name = world.getName();
+                        final String dimension =
+                            WordUtils.capitalizeFully(world.getEnvironment().name().replace('_', ' '));
+                        final long seed = world.getSeed();
+                        final String difficulty =
+                            WordUtils.capitalizeFully(world.getDifficulty().name().replace('_', ' '));
+                        final List<String> players =
+                            world.getPlayers().stream().map(Player::getDisplayName).collect(Collectors.toList());
+                        final String time = String.valueOf((int) Math.floor((double) world.getTime() / 10.0));
+
+                        return new WorldStatus(name, dimension, seed, difficulty, players, time);
+                    }).collect(Collectors.toList());
+
+                    final double[] tps = Bukkit.getTPS();
+
+                    final long freeMem = Runtime.getRuntime().freeMemory();
+                    final long currentMem = Runtime.getRuntime().totalMemory();
+                    final long maxMem = Runtime.getRuntime().maxMemory();
+
+                    sendMessage(responseChan, new StatusMessageResponse(
+                        motd, serverName, serverVersion, numPlayers, worlds,
+                        new TpsStatus(tps),
+                        new MemoryStatus(freeMem, currentMem, maxMem)
+                    ));
+                });
+            }
+
+            static class StatusMessageResponse {
+                final String motd;
+                final String serverName;
+                final String serverVersion;
+                final int numPlayers;
+                final List<WorldStatus> worlds;
+                final TpsStatus tps;
+                final MemoryStatus memoryUsage;
+
+                StatusMessageResponse(
+                    final String motd,
+                    final String serverName,
+                    final String serverVersion,
+                    final int numPlayers,
+                    final List<WorldStatus> worlds,
+                    final TpsStatus tps,
+                    final MemoryStatus memoryUsage
+                ) {
+                    this.motd = motd;
+                    this.serverName = serverName;
+                    this.serverVersion = serverVersion;
+                    this.numPlayers = numPlayers;
+                    this.worlds = worlds;
+                    this.tps = tps;
+                    this.memoryUsage = memoryUsage;
+                }
+            }
+
+            static class WorldStatus {
+                final String name;
+                final String dimension;
+                final long seed;
+                final String difficulty;
+                final List<String> players;
+                final String time;
+
+                WorldStatus(
+                    final String name,
+                    final String dimension,
+                    final long seed,
+                    final String difficulty,
+                    final List<String> players,
+                    final String time
+                ) {
+                    this.name = name;
+                    this.dimension = dimension;
+                    this.seed = seed;
+                    this.difficulty = difficulty;
+                    this.players = players;
+                    this.time = time;
+                }
+            }
+
+            static class TpsStatus {
+                final double oneMin;
+                final double fiveMin;
+                final double fifteenMin;
+
+                TpsStatus(final double[] mins) {
+                    this.oneMin = mins[0];
+                    this.fiveMin = mins[1];
+                    this.fifteenMin = mins[2];
+                }
+            }
+
+            static class MemoryStatus {
+                final String usedMemory;
+                final String totalMemory;
+                final String maxMemory;
+
+                MemoryStatus(final long freeMemory, final long totalMemory, final long maxMemory) {
+                    final long usedMemory = totalMemory - freeMemory;
+                    this.usedMemory = (usedMemory / 1_000_000) + " MB";
+                    this.totalMemory = (totalMemory / 1_000_000) + " MB";
+                    this.maxMemory = maxMemory == Long.MAX_VALUE ? "Not Set" : ((maxMemory / 1_000_000) + " MB");
+                }
+            }
+        }
+    }
+
+    private static void sendMessage(final int channel, final Object data) {
+        final String json = gson.toJson(data);
+        System.out.println("Sending response data: " + json);
+
+        final byte[] rawData = json.getBytes(StandardCharsets.UTF_8);
+
+        int index = 0;
+        while (index < rawData.length) {
+            final int size = Math.min(rawData.length - index, IPCLibrary.Data.MESSAGE_LENGTH);
+
+            try {
+                sendPagedMessage(channel, rawData, index, size, index + size == rawData.length);
+            } catch (final LastErrorException e) {
+                final String msg = IPCLibrary.strerror(e.getErrorCode());
+                log(logger -> logger.warning("Failed to send to message queue: " + msg));
+                return;
+            }
+
+            index += size;
+        }
+    }
+
+    private static void sendPagedMessage(
+        final int channel,
+        final byte[] data,
+        final int index,
+        final int length,
+        final boolean isFin
+    ) throws LastErrorException {
+        final IPCLibrary.MsgBuf buf = new IPCLibrary.MsgBuf();
+
+        System.arraycopy(data, index, buf.data.message, 0, length);
+        buf.data.messageLength = (byte) length;
+        if (isFin) {
+            buf.data.messageLength |= (byte) 0x80;
+        }
+
+        IPCLibrary.msgsnd(channel, buf, buf.data.size(), 0);
+    }
+
+    static class ServerErrorMessage {
+        final String error;
+
+        ServerErrorMessage(final String message) {
+            this.error = message;
+        }
+    }
+
+    private static void serverNotReadyYet(final int channel) {
+        sendMessage(channel, new ServerErrorMessage("Server not ready yet"));
+    }
+
+    // The code in this file can sometimes run much sooner than CraftBukkit has had time to initialize. With this taken
+    // into consideration, extra care must be taken to prevent NPEs from code which would always be safe in normal
+    // conditions.
+    //
+
+    private static CraftServer getCraftServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    private static DedicatedServer getConsole() {
+        final CraftServer server = getCraftServer();
+        //noinspection ConstantConditions
+        if (server == null) {
+            return null;
+        }
+        return server.console;
+    }
+
+    /**
+     * Provide a {@code consumer} to use to execute a log statement immediately, or in the future once the system Logger
+     * is available if it is not already. This method exists because there may be cases where important log messages are
+     * printed before the server has fully started and the system logger has been created. In these cases, to make sure
+     * no critical information is lost due to this, this method will create a new thread to wait for the system logger
+     * to become available before executing the provided {@code consumer}. The cost of creating a new thread is
+     * negligible as this will likely rarely, if ever, happen, and if it does the volume will likely not go much higher
+     * than 1.
+     *
+     * @param consumer The {@link Consumer} to execute with the system logger once it is available.
+     */
+    private static void log(final Consumer<Logger> consumer) {
+        {
+            final CraftServer server = getCraftServer();
+            //noinspection ConstantConditions
+            if (server != null) {
+                consumer.accept(server.getLogger());
+                return;
+            }
+        }
+
+        final Thread t = new Thread(() -> {
+            while (true) {
+                try {
+                    Thread.sleep(500);
+                } catch (final InterruptedException ignored) {
+                }
+
+                final CraftServer server = getCraftServer();
+                if (server != null) {
+                    consumer.accept(server.getLogger());
+                    return;
+                }
+            }
+        });
+        t.setDaemon(true);
+        t.start();
+    }
+
+    static class PaperDaemonException extends RuntimeException {
+        PaperDaemonException(final String message) {
+            super(message);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index c1834d18b..dd02ebbcc 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -210,7 +210,7 @@ public final class CraftServer implements Server {
     private final SimpleHelpMap helpMap = new SimpleHelpMap(this);
     private final StandardMessenger messenger = new StandardMessenger();
     private final SimplePluginManager pluginManager = new SimplePluginManager(this, commandMap);
-    protected final DedicatedServer console;
+    public final DedicatedServer console; // Paper - make public
     protected final DedicatedPlayerList playerList;
     private final Map<String, World> worlds = new LinkedHashMap<String, World>();
     private YamlConfiguration configuration;
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 405ea5c46..bc394f2f3 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -20,6 +20,8 @@ public class Main {
     public static boolean useConsole = true;
 
     public static void main(String[] args) {
+        if (com.destroystokyo.paper.PaperDaemon.init()) { useJline = false; useConsole = false; } // Paper - daemon mode
+
         // Todo: Installation script
         OptionParser parser = new OptionParser() {
             {
-- 
2.22.0

